{
  "name": "client-sessions",
  "version": "0.7.0",
  "description": "secure sessions stored in cookies",
  "main": "lib/client-sessions",
  "repository": {
    "type": "git",
    "url": "https://github.com/mozilla/node-client-sessions"
  },
  "dependencies": {
    "cookies": "0.5.0"
  },
  "devDependencies": {
    "vows": "0.7.0",
    "express": "2.5.0",
    "tobi": "https://github.com/Cowboy-coder/tobi/tarball/fd733a3",
    "zombie": "1.4.1"
  },
  "author": {
    "name": "Ben Adida",
    "email": "ben@adida.net"
  },
  "scripts": {
    "test": "vows --spec"
  },
  "engines": {
    "node": ">= 0.8.0"
  },
  "licenses": {
    "type": "MPL 2.0",
    "url": "https://raw.github.com/mozilla/node-client-sessions/master/LICENSE"
  },
  "bugs": {
    "url": "https://github.com/mozilla/node-client-sessions/issues"
  },
  "readme": "[![build status](https://secure.travis-ci.org/mozilla/node-client-sessions.png)](http://travis-ci.org/mozilla/node-client-sessions)\r\n\r\nclient-sessions is connect middleware that implements sessions in encrypted tamper-free cookies.  For a complete introduction to encrypted client side sessions, refer to [Francois Marier's blog post on the subject][];\r\n\r\n[Francois Marier's blog post on the subject]: https://hacks.mozilla.org/2012/12/using-secure-client-side-sessions-to-build-simple-and-scalable-node-js-applications-a-node-js-holiday-season-part-3/\r\n\r\n**NOTE:** It is not recommended using both this middleware and connect's built-in session middleware.\r\n\r\n## Usage\r\n\r\nBasic usage:\r\n\r\n```js\r\nvar sessions = require(\"client-sessions\");\r\napp.use(sessions({\r\n  cookieName: 'mySession', // cookie name dictates the key name added to the request object\r\n  secret: 'blargadeeblargblarg', // should be a large unguessable string\r\n  duration: 24 * 60 * 60 * 1000, // how long the session will stay valid in ms\r\n  activeDuration: 1000 * 60 * 5 // if expiresIn < activeDuration, the session will be extended by activeDuration milliseconds\r\n}));\r\n\r\napp.use(function(req, res, next) {\r\n  if (req.mySession.seenyou) {\r\n    res.setHeader('X-Seen-You', 'true');\r\n  } else {\r\n    // setting a property will automatically cause a Set-Cookie response\r\n    // to be sent\r\n    req.mySession.seenyou = true;\r\n    res.setHeader('X-Seen-You', 'false');\r\n  }\r\n});\r\n```\r\n\r\nYou can control more specific cookie behavior during setup:\r\n\r\n```js\r\napp.use(sessions({\r\n  cookieName: 'mySession', // cookie name dictates the key name added to the request object\r\n  secret: 'blargadeeblargblarg', // should be a large unguessable string\r\n  duration: 24 * 60 * 60 * 1000, // how long the session will stay valid in ms\r\n  cookie: {\r\n    path: '/api', // cookie will only be sent to requests under '/api'\r\n    maxAge: 60000, // duration of the cookie in milliseconds, defaults to duration above\r\n    ephemeral: false, // when true, cookie expires when the browser closes\r\n    httpOnly: true, // when true, cookie is not accessible from javascript\r\n    secure: false // when true, cookie will only be sent over SSL. use key 'secureProxy' instead if you handle SSL not in your node process\r\n  }\r\n}));\r\n```\r\n\r\nYou can have multiple cookies:\r\n\r\n```js\r\n// a 1 week session\r\napp.use(sessions({\r\n  cookieName: 'shopping_cart',\r\n  secret: 'first secret',\r\n  duration: 7 * 24 * 60 * 60 * 1000\r\n}));\r\n\r\n// a 2 hour encrypted session\r\napp.use(sessions({\r\n  cookieName: 'authenticated',\r\n  secret: 'first secret',\r\n  duration: 2 * 60 * 60 * 1000\r\n}));\r\n```\r\n\r\nIn this example, there's a 2 hour authentication session, but shopping carts persist for a week.\r\n\r\nFinally, you can use requestKey to force the name where information can be accessed on the request object.\r\n\r\n```js\r\nvar sessions = require(\"client-sessions\");\r\napp.use(sessions({\r\n  cookieName: 'mySession',\r\n  requestKey: 'forcedSessionKey', // requestKey overrides cookieName for the key name added to the request object.\r\n  secret: 'blargadeeblargblarg', // should be a large unguessable string or Buffer\r\n  duration: 24 * 60 * 60 * 1000, // how long the session will stay valid in ms\r\n}));\r\n\r\napp.use(function(req, res, next) {\r\n  // requestKey forces the session information to be\r\n  // accessed via forcedSessionKey\r\n  if (req.forcedSessionKey.seenyou) {\r\n    res.setHeader('X-Seen-You', 'true');\r\n  }\r\n  next();\r\n});\r\n```\r\n\r\n## Cryptography\r\n\r\nA pair of encryption and signature keys are derived from the `secret` option\r\nvia HMAC-SHA-256; the `secret` isn't used directly to encrypt or compute the\r\nMAC.\r\n\r\nThe key-derivation function, in pseudocode:\r\n\r\n```text\r\n  encKey := HMAC-SHA-256(secret, 'cookiesession-encryption');\r\n  sigKey := HMAC-SHA-256(secret, 'cookiesession-signature');\r\n```\r\n\r\nThe **AES-256-CBC** cipher is used to encrypt the session contents, with an\r\n**HMAC-SHA-256** authentication tag (via **Encrypt-then-Mac** composition).  A\r\nrandom 128-bit Initialization Vector (IV) is generated for each encryption\r\noperation (this is the AES block size regardless of the key size).  The\r\nCBC-mode input is padded with the usual PKCS#5 scheme.\r\n\r\nIn pseudocode, the encryption looks like the following, with `||` denoting\r\nconcatenation. The `createdAt` and `duration` parameters are decimal strings.\r\n\r\n```text\r\n  iv := secureRandom(16 bytes)\r\n  ciphertext := AES-256-CBC(encKey, iv, sessionJson)\r\n  payload := iv || '.' || ciphertext || '.' || createdAt || '.' || duration\r\n  hmac := HMAC-SHA-256(sigKey, payload)\r\n  cookie := base64url(iv) || '.' ||\r\n    base64url(ciphertext) || '.' ||\r\n    createdAt || '.' ||\r\n    duration || '.' ||\r\n    base64url(hmac)\r\n```\r\n\r\nFor decryption, a constant-time equality operation is used to verify the HMAC\r\noutput to avoid the plausible timing attack.\r\n\r\n### Advanced Cryptographic Options\r\n\r\nThe defaults are secure, but may not suit your requirements. Some example scenarios:\r\n- You want to use randomly-generated keys instead of using the key-derivation\r\n  function used in this module.\r\n- AES-256 is overkill for the type of data you store in the session (e.g. not\r\n  personally-identifiable or sensitive) and you'd like to trade-off decreasing\r\n  the security level for CPU economy.\r\n- SHA-256 is maybe too weak for your application and you want to have more\r\n  MAC security by using SHA-512, which grows the size of your cookies slightly.\r\n\r\nIf the defaults don't suit your needs, you can customize client-sessions.\r\n**Beware: Changing keys and/or algorithms will make previously-generated\r\nCookies invalid!**\r\n\r\n#### Configuring Keys\r\n\r\nTo configure independent encryption and signature (HMAC) keys:\r\n\r\n```js\r\napp.use(sessions({\r\n  encryptionKey: loadFromKeyStore('session-encryption-key'),\r\n  signatureKey: loadFromKeyStore('session-signature-key'),\r\n  // ... other options discussed above ...\r\n}));\r\n```\r\n\r\n#### Configuring Algorithms\r\n\r\nTo specify custom algorithms and keys:\r\n\r\n```js\r\napp.use(sessions({\r\n  // use WEAKER-than-default encryption:\r\n  encryptionAlgorithm: 'aes128',\r\n  encryptionKey: loadFromKeyStore('session-encryption-key'),\r\n  // use a SHORTER-than-default MAC:\r\n  signatureAlgorithm: 'sha256-drop128',\r\n  signatureKey: loadFromKeyStore('session-signature-key'),\r\n  // ... other options discussed above ...\r\n}));\r\n```\r\n\r\n#### Encryption Algorithms\r\n\r\nSupported CBC-mode `encryptionAlgorithm`s (and key length requirements):\r\n\r\n| Cipher | Key length |\r\n| ------ | ---------- |\r\n| aes128 | 16 bytes   |\r\n| aes192 | 24 bytes   |\r\n| aes256 | 32 bytes   |\r\n\r\nThese key lengths are exactly as required by the [Advanced Encryption\r\nStandard](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard).\r\n\r\n#### Signature (HMAC) Algorithms\r\n\r\nSupported HMAC `signatureAlgorithm`s (and key length requirements):\r\n\r\n| HMAC           | Minimum Key Length | Maximum Key Length |\r\n| -------------- | ------------------ | ------------------ |\r\n| sha256         | 32 bytes           | 64 bytes           |\r\n| sha256-drop128 | 32 bytes           | 64 bytes           |\r\n| sha384         | 48 bytes           | 128 bytes          |\r\n| sha384-drop192 | 48 bytes           | 128 bytes          |\r\n| sha512         | 64 bytes           | 128 bytes          |\r\n| sha512-drop256 | 64 bytes           | 128 bytes          |\r\n\r\nThe HMAC key length requirements are derived from [RFC 2104 section\r\n3](https://tools.ietf.org/html/rfc2104#section-3). The maximum key length can\r\nbe exceeded, but it doesn't increase the security of the signature.\r\n\r\nThe `-dropN` algorithms discard the latter half of the HMAC output, which\r\nprovides some additional protection against SHA2 length-extension attacks on\r\ntop of HMAC. The same technique is used in the upcoming [JSON Web Algorithms\r\n`AES_CBC_HMAC_SHA2` authenticated\r\ncipher](http://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-19#section-5.2).\r\n\r\n#### Generating Keys\r\n\r\nOne can easily generate both AES and HMAC-SHA2 keys via command line: `openssl\r\nrand -base64 32` for a 32-byte (256-bit) key.  It's easy to then parse that\r\noutput into a `Buffer`:\r\n\r\n```js\r\nfunction loadKeyFromStore(name) {\r\n  var text = myConfig.keys[name];\r\n  return new Buffer(text, 'base64');\r\n}\r\n```\r\n\r\n#### Key Constraints\r\n\r\nIf you specify `encryptionKey` or `signatureKey`, you must supply the other as\r\nwell.\r\n\r\nThe following constraints must be met or an `Error` will be thrown:\r\n\r\n1. both keys must be `Buffer`s.\r\n2. the keys must be _different_.\r\n3. the encryption key are _exactly_ the length required (see above).\r\n4. the signature key has _at least_ the length required (see above).\r\n\r\nBased on the above, please note that if you specify a `secret` _and_ a\r\n`signatureAlgorithm`, you need to use `sha256` or `sha256-drop128`.\r\n\r\n## License\r\n\r\n> This Source Code Form is subject to the terms of the Mozilla Public\r\n> License, v. 2.0. If a copy of the MPL was not distributed with this\r\n> file, You can obtain one at http://mozilla.org/MPL/2.0/.\r\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/mozilla/node-client-sessions",
  "_id": "client-sessions@0.7.0",
  "_from": "client-sessions@0.7.0"
}
